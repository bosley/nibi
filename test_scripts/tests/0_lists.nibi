(:= x [])

# Chain together push_fronts to ensure lists being returned by each
# Implicitly convert the list to string for checking

(assert (eq "[10 20 30]" (>| 10 (>| 20 (>| 30 x)))) "No dice")

(:= y [])

(assert (eq "[30 20 10]" (|< 10 (|< 20 (|< 30 y)))) "No dice")

# push y into x

(assert (eq "[10 20 30 [30 20 10]]" (|< y x)) "No dice")

(:= values [])

# Iterate over y and collect the values and indicies that
# exist to check later
(iter y temp_iter_val [
  (|< temp_iter_val values)
])

(:= did_drop 0)
(try [
  (drop temp_iter_val)
  (set did_drop 1)
] [ 
  # Expected
])

(assert (eq 0 did_drop) "temp_iter_val wasnt cleaned")

(assert (eq y values) "No dice")

(:= temp [1 2 3])

# Note: to update you have to use `set`
(iter temp temp_iter_val (set temp_iter_val (+ 1 temp_iter_val)))

(assert (eq "[2 3 4]" temp) "No dice")

(:= some_list [0 0 0 0 0 0 0 0 9 0])

(assert (eq 9 (at some_list 8)) "Incorrect item retrieved")

# We can't embed this into the assert, because set returns the cell that 
# was updated. In this case the cell that was updated was an individual subset
# of the entire list

(set (at some_list 4) 1)

(assert  (eq "[0 0 0 0 1 0 0 0 9 0]" some_list) "At failure")

(assert (eq 22 (at [0 1 2 3 4 22 6 7 8] 5)) "Nope")

(assert (eq 22 (at [0 1 2 3 4 22 6 7 8] (+ 3 1 1))) "Nope")

# List spawning!

(assert (eq 100 (len (:= large_list (<|> "." 100)))) "Nope")

(assert (eq 100 (len (:= large_list (<|> "." (* 10 10))))) "Nope")

# Push and pop

(assert (eq "[1 2 3 4 5]" (|>> [1 2 3 4 5 6])) "nope")

(assert (eq "[2 3 4 5 6]" (<<| [1 2 3 4 5 6])) "nope")

(:= new_target 0)
(:= nt_list [1 2 3 new_target 5 6 7])

(set (at nt_list 3) 4)

(assert (eq 4 new_target) "Nope")

(assert (eq "[1 2 3 new_target 5 6 7]" nt_list) "Nope")

(iter nt_list temp_iter_val [
  (set temp_iter_val (+ 1 temp_iter_val))
])

(assert (eq 5 new_target) "Nope")

(:= other_list [1 2])

# put the item into the list by value

(|< new_target other_list)

(assert (eq 5 (at other_list 2)) "Nope")

(set (at other_list 2) 3)

(assert (eq 3 (at other_list 2)) "Nope")

# ensure that the item is in by value
# and new_target wasn't updated

(assert (eq 5 new_target) "Nope")

# again but with at

(set (at other_list 2) new_target)

(assert (eq 5 (at other_list 2)) "Nope")

(set (at other_list 2) 3)

(assert (eq 5 new_target) "Nope")


